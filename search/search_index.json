{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The GLACIER Project","text":""},{"location":"#overview","title":"Overview","text":"<p>The GLACIER project aims to create an open-source ecosystem for designing, prototyping, monitoring, and optimizing cyber-physical production systems (CPPSs). With steadily increasing complexity of manufacturing systems and the integration of software in manufacturing systems, the need for tools supporting the design, prototyping, monitoring, and optimization of production systems has become more important. </p> <p>The GLACIER ecosystem provides a simplified environment for developing CPPSs Digital Twins (DTs), where software and physical components are seamlessly integrated.  Physical components represent the real-world manufacturing machines, sensors, and actuators, while software components represent the software controlling, monitoring, and optimizing the production system.  GLACIER supports different levels of fidelity, from simple data-mirroring models to complex predictive simulations. The architecture is designed to be modular, scalable, and extensible. This flexibility allows users to start with basic digital representations and gradually enhance them as requirements evolve.</p>"},{"location":"#the-frost-platform","title":"The Frost Platform","text":"<p>The Frost platform is the core of the GLACIER ecosystem, providing a simulation environment for developing and testing CPPSs. Frost allows users to create high-fidelity digital twins of production systems replicating the Application Programming Interfaces (APIs) exposed by real systems. Such an environment reduces the time spent adapting and deploying prototype software on the target system.</p> <p>Frost is built on Lingua Franca, a polyglot coordination language supporting the development of deterministic distributed programs that can be deployed on the Cloud, the Edge, and even on bare-metal architectures. This combination makes it ideal for enhancing the reliability of software prototyping and testing. At its core, the Frost platform follows a modular architecture with several key components:</p> <ul> <li>Data Model: the interface between the machine and the other components of the platform. Inspired by the OPC UA Information model, it consists of a tree-like structure containing the variables that represent the state of the machine, and the methods that represents the exposed functionalities. </li> <li>FrostMachine: physical components of the production system, such as machines, sensors, and actuators. Machines can be represented with different levels of fidelity, from simple delay-based models to physics-based simulations.</li> <li>Actor: components that interact with the machines or other actors. Actors can be used to implement control algorithms, monitoring applications, or optimization algorithms. </li> <li>FrostBus: the communication infrastructure of the production system, where software components and physical components interact. The bus is responsible for routing messages between components and ensuring that the system is in a consistent state.</li> </ul>"},{"location":"#data-model","title":"Data Model","text":"<p>The machine data model is the interface between the machine and the other components of the platform. It is inspired by the OPC UA Information model and consists of a tree-like structure containing the variables that represent the state of the machine. Specifically, the data model supports the following types of variables:</p> <ul> <li>FolderNode: folders that contain other variables. Folders can be nested to create a tree-like structure.</li> <li>VariableNode: variables that represent the state of the machine. Variables can be of different types, such as integers, floats, strings, booleans, etc.</li> <li>ObjectNode: objects that represent complex components of the machine. Objects can contain other variables or objects.</li> <li>MethodNode: synchronous methods that can be invoked to perform actions on the machine. Methods can accept arguments and return values. A synchronous method returns the result of the command only after the command has been successfully executed or has failed. They can be used to represent actions that are executed across multiple time steps.</li> <li>AsyncMethodNode: asynchronous methods return immediately. The completion of the command is signaled through an update of one or more variables in the data model. They can be used to represent actions changing the state of the machine (e.g., turning on a motor).</li> <li>CompositeMethodNode: composite methods are defined as a sequence of operations performed on the data model. The operations may include the execution of asynchronous methods, reading and writing variables, and waiting for specific conditions on the data model. When a composite method is invoked, it returns immediately, returning an acceptance value, while when it is completed, an update message is sent to the caller. </li> </ul> <p>The data model is specified in a YAML file that describes the structure of the tree and the variables that compose the model. The following example shows a data model for a production machine that checks the quality of a product.</p> control_quality.yaml<pre><code>name: \"control_quality\" # name of the machine\ndescription: \"A simple quality control machine\" # description of the machine\nroot:\n  !!FolderNode\n  name: \"control_quality\"\n  description: \"Root folder of the control quality machine\"\n  children:\n    - !!FolderNode\n      name: \"statistics\"\n      description: \"Statistics folder\"\n      children:\n        - !!NumericalVariableNode\n            name: \"#checks\"\n            description: \"Total number of checks\"\n            initial_value: 0\n        - !!NumericalVariableNode\n            name: \"failures\"\n            description: \"Number of failed checks\"\n            initial_value: 5.0\n        - !!AsyncMethodNode\n          name: \"check_quality\"\n          description: \"Check the quality of a product\"\n          parameters:\n            - !!StringVariableNode\n              name: \"product_info\"\n              description: \"Information about the product\"\n              default_value: \"default\"\n          returns:\n            - !!BooleanVariableNode\n              name: \"result\"\n              description: \"Result of the quality check\"\n</code></pre>"},{"location":"#frost-machines","title":"Frost Machines","text":"<p>In the Frost platform, machines are the physical components of the production system. Each machine is represented as a single entity, which can be a physical machine, a sensor, or an actuator. Interactions with a machine occur through the machine's data model, which represents the current state of the machine. This enables decoupling the execution logic of the machine from that of other components, increasing the modularity and flexibility of the platform. To create a new machine, you need to extend the base reactor <code>FrostMachine</code> and implement the necessary methods for the simulation or control of the machine.</p> ControlQuality.lf<pre><code>reactor ControlQuality extends FrostMachine{\n    state total_checks\n    state failures\n\n    reaction(startup){=\n        self.total_checks = self.data_model.get_node(\"control_quality/statistics/#checks\")\n        self.failures = self.data_model.get_node(\"control_quality/statistics/failures\")\n        check_quality_covers = self.data_model.get_node(\"control_quality/statistics/check_quality\")\n        check_quality_covers.callback = self.check_quality\n    =}\n\n    method check_quality(product_info){=\n        self.total_checks.value += 1\n\n        if product_info != \"good\":\n            self.failures.value += 1\n            return False\n        return True\n    =}\n}\n</code></pre> <p>The example above shows a simple implementation of a quality control machine that checks the quality of a product. The machine references the data model presented above, adding the necessary logic implementing the machine behavior. The state of the machine is represented by the <code>total_checks</code> and <code>failures</code> variables, which are initialized at startup. These variables reference the corresponding variables in the data model. Changes to the state of these variables are transparently handled by the machine data model and the <code>FrostMachine</code> base class.</p>"},{"location":"#actor","title":"Actor","text":"<p>Actors are software components that interact with machines or other actors. They can be used to implement control algorithms, monitoring applications, or optimization algorithms. Actors interact with machines or with other actors by reading and writing variables in the machine data model, invoking methods on the machine, or subscribing to changes in the data model's state.</p>"},{"location":"#frost-bus","title":"Frost Bus","text":"<p>Modern manufacturing systems follows the Service-oriented Manufacturing (SoM) paradigm, which organizes the system as a set of machine services that can be accessed and used by other entities in the system. The implementation of the SoM paradigm is usually based on a centralized message broker that routes messages between the different components of the system.  To emulate this behavior, the Frost platform includes a bus component that serves as a communication infrastructure for the system. The bus component is responsible for routing messages between machines and actors, ensuring that the system is in a consistent state.</p> <p>Note</p> <p>The bus component is optional and can be replaced by direct communication between actors and machines for brokerless architectures.</p>"},{"location":"#wrapping-up","title":"Wrapping Up","text":"<p>Below is a simple example of a production system that includes a quality control machine and an actor that interacts with the machine. The actor invokes the <code>check_quality</code> method to check the quality of a product and prints the result of the check. The machine keeps track of the total number of checks and the number of failed checks.</p> ControlQualityActor.lf<pre><code>target Python{\n    fast: True,\n}\n\nimport ControlQuality from \"ControlQuality.lf\"\nimport FrostBus from \"FrostBus.lf\"\n\nreactor ControlQualityActor extends FrostMachine{\n\n    reaction(startup) -&gt; channel_out{=\n        # send a message to the machine to check the quality of a product\n        msg = get_cm_msg(target=\"qc\", method_name=\"control_quality/statistics/check_quality\", args=[\"good\"])\n        # alternatively, you can specify the arguments as a dictionary\n        # msg = get_cm_msg(target=\"qc\", method_name=\"control_quality/statistics/check_quality\", kwargs={\"product_info\": \"good\"})\n\n        channel_out.set(msg)\n    =}\n\n    reaction(channel_in){=\n        print(\"Received message: \", self.channel_in.value)\n    =}\n}\n\nmain reactor{\n    qc_actor = new ControlQualityActor()\n    qc = new ControlQuality(model_path=\"models/control_quality.yml\")\n    bus = new FrostBus(model_path=\"models/bus.yml\",width=2)\n\n    qc_actor.channel_out, qc.channel_out -&gt; bus.channel_in \n    bus.channel_out -&gt; qc.channel_in, qc_actor.channel_in \n}\n</code></pre>"},{"location":"#roadmap","title":"Roadmap","text":"<p>The GLACIER ecosystem is under active development. The following roadmap outlines the key milestones and features that will be added to the platform in the coming months.</p> <pre><code>timeline\n    title GLACIER Roadmap\n    2025-03-31: First release\n    2025-04-30: SysML v2 integration: Data-driven machine simulation\n    2025-05-31: Physic-based machine simulation: Machine-in the loop simulation\n    2025-07-31: FMI/FMU integration\n    2025-12-31: Verification, validation, and testing\n    2026-03-31: Advanced Human-Machine Interaction</code></pre>"},{"location":"#license","title":"License","text":"<p>The Frost platform and the data model library are released under the BSD 2-Clause License.</p>"},{"location":"#contact","title":"Contact","text":"<p>For technical support, collaborations, or further information, contact:</p> <p>Sebastiano Gaiardelli (sebastiano.gaiardelli@univr.it), Department of Engineering for Innovation Medicine University of Verona, Section of Engineering and Physics, Italy</p>"},{"location":"diagrams/sequence/async_method/","title":"Async method","text":"<p>Asynchronous method invocation: <pre><code>sequenceDiagram\n    autonumber\n    participant A as Actor \n    participant B as Bus\n    participant M as Machine\n    A-)B: Invoke(method_name, args, kwargs)\n    activate B\n    B-)M: Invoke(method_name, args, kwargs)\n    activate M\n    M--)B: Accepted(method_name, args, kwargs)\n    B--)A: Accepted(method_name, args, kwargs)\n    M-)M: Execute(method_name, args, kwargs)\n    M-)B: Update(variable=value)\n    deactivate M\n    B-)A: Update(variable=value)\n    deactivate B</code></pre></p>"},{"location":"diagrams/sequence/composite_method/","title":"Composite method","text":"<p>Composite method invocation: <pre><code>sequenceDiagram\n    autonumber\n    participant A as Actor \n    participant B as Bus\n    participant M as Machine\n    A-)B: Invoke(method_name, args, kwargs)\n    activate B\n    B-)M: Invoke(method_name, args, kwargs)\n    activate M\n    M--)B: Accepted(method_name, args, kwargs)\n    B--)A: Accepted(method_name, args, kwargs)\n    loop !end_condition\n        M-)M: Execute(method_name, args, kwargs)\n    end\n    M-)B: Return(results)\n    deactivate M\n    B-)A: Return(results)\n    deactivate B</code></pre></p>"},{"location":"diagrams/sequence/method/","title":"Method","text":"<p>Synchronous method invocation: <pre><code>sequenceDiagram\n    autonumber\n    participant A as Actor \n    participant B as Bus\n    participant M as Machine\n    A-&gt;&gt;B: Invoke(method_name, args, kwargs)\n    activate B\n    B-&gt;&gt;M: Invoke(method_name, args, kwargs)\n    activate M\n    M-&gt;&gt;M: Execute(method_name, args, kwargs)\n    M-&gt;&gt;B: Return(results)\n    deactivate M\n    B-&gt;&gt;A: Return(results)\n    deactivate B</code></pre></p>"},{"location":"doc_sources/Frost_Base/","title":"<code>FrostBase</code> Reactor","text":"<p>The <code>FrostBase</code> reactor serves as the foundational component for all other reactors in the Frost framework. It provides a set of common utility methods and basic functionalities that are inherited by other, more specialized reactors. Its primary purpose is to offer a standard toolkit for logging, parameter handling, and message passing, ensuring consistency across the entire system.</p>"},{"location":"doc_sources/Frost_Base/#core-functionalities","title":"Core Functionalities","text":"<ul> <li>Logging: Initializes a logger for each reactor instance, allowing for standardized and configurable logging.</li> <li>Parameter Overriding: Includes a method to override a reactor's default parameters with values from a configuration file. This allows for flexible and centralized configuration management.</li> <li>Message-Passing Utilities: Provides helper methods like <code>_set_output_port</code> and <code>_get_input_values</code> to simplify the process of sending and receiving messages through ports, including handling multiport outputs.</li> </ul>"},{"location":"doc_sources/Frost_Base/#configuration-and-parameter-overriding","title":"Configuration and Parameter Overriding","text":"<p>One of the key features provided by <code>FrostBase</code> is the ability to override a reactor's parameters from an external configuration file. This allows for highly flexible and centralized management of reactor settings without modifying the source code.</p>"},{"location":"doc_sources/Frost_Base/#configuration-file-example","title":"Configuration File Example","text":"<p>The configuration is typically provided in a YAML file. This file can define settings for multiple reactors, including their logging levels and any custom parameters.</p> <p>Here is an example of a <code>config.yml</code> file:</p> <pre><code>reactors:\n  my_reactor_instance:\n    logging_level: \"DEBUG\"\n    parameters:\n      update_interval: 500  # msec\n      threshold: 42.5\n</code></pre> <p>In this example, we are defining settings for a reactor instance named <code>my_reactor_instance</code>. We are setting its logging level to <code>DEBUG</code> and overriding two of its parameters: <code>update_interval</code> and <code>threshold</code>.</p>"},{"location":"doc_sources/Frost_Base/#how-it-works","title":"How It Works","text":"<ol> <li>Loading the Configuration: At the start of the simulation, this YAML file is loaded into a Python dictionary.</li> <li>Passing to the Reactor: This dictionary is then passed to the reactor, typically during its initialization.</li> <li>Overriding Parameters: The <code>__override_initial_parameters</code> method is called within the reactor's startup sequence. This method explores the configuration dictionary to find the section corresponding to the reactor's name. It then dynamically updates the reactor's attributes (<code>self.update_interval = 500</code>, <code>self.threshold = 42.5</code>) using the values from the file.</li> </ol> <p>This mechanism allows you to easily change reactor behavior for different simulation runs just by modifying the configuration file.</p>"},{"location":"doc_sources/Frost_Base/#code-snippets","title":"Code Snippets","text":"<p>Parameter Overriding Method</p> <p>This is the method within <code>FrostBase</code> that performs the dynamic parameter update.</p> <pre><code>method __override_initial_parameters(configuration, reactor_name) {=\n    // ... search for the reactor's configuration in the dictionary ...\n\n    if \"parameters\" not in configuration or not isinstance(configuration[\"parameters\"], dict):\n        return\n\n    for key, value in configuration[\"parameters\"].items():\n        if not hasattr(self, key):\n            self.logger.warning(f\"Parameter {key} not found in reactor {reactor_name}. Creating dynamic parameter {key} = {value}.\")\n\n        setattr(self, key, value)\n=}\n</code></pre> <p>Setting Output Port Value</p> <p>This utility method simplifies the process of setting or appending values to an output port, which is fundamental for message passing.</p> <pre><code>method _set_output_port(value, output_port) {=\n    '''Set the output value for the specified output port. If a value is already set, it will append the new value to the existing one.'''\n\n    if output_port.width &gt; 0:\n        self._set_output_multiport(value, output_port, None)\n        return\n\n    if not output_port.is_present:\n        output_port.set([])\n\n    if isinstance(value, list):\n        output_port.value.extend(value)\n    else:\n        output_port.value.append(value)\n=}\n</code></pre>"},{"location":"doc_sources/Frost_Bus/","title":"<code>FrostBus</code> Reactor","text":"<p>The <code>FrostBus</code> is a central component in the Frost architecture that acts as a message router. It is responsible for managing the registration of different Frost components and ensuring that messages are delivered to their intended targets. It extends <code>FrostDataModel</code>, allowing it to have its own data model for tracking registered machines.</p>"},{"location":"doc_sources/Frost_Bus/#core-functionalities","title":"Core Functionalities","text":"<ul> <li>Component Registration: The <code>FrostBus</code> listens for registration requests from other Frost components. When a component sends a <code>REGISTER</code> message, the bus adds it to a <code>routing_map</code>, which maps the component's name to its bus index.</li> <li>Message Routing: It overrides the <code>_set_channel_out_port</code> method to implement its routing logic. When it receives a message to send, it looks up the target in its <code>routing_map</code> and forwards the message to the correct output port connected to that target.</li> <li>Data Model Management: The bus maintains a data model that keeps track of the number of registered machines and information about each one, such as its index on the bus.</li> </ul>"},{"location":"doc_sources/Frost_Bus/#code-snippets","title":"Code Snippets","text":"<p>Handling Registration Requests</p> <p>This reaction processes registration requests from new components, adding them to the routing map and updating the data model.</p> <pre><code>reaction(message_filter.requests) -&gt; channel_out {=\n    for bank_index, message in message_filter.requests.value:\n        if message.header.namespace != MsgNamespace.PROTOCOL or message.header.msg_name != ProtocolMsgName.REGISTER:\n            continue\n\n        if message.sender in self.routing_map:\n            continue\n\n        self.routing_map[message.sender] = bank_index\n\n        # ... update data model with new machine info ...\n\n        self.number_of_machines.value += 1\n\n        # Send a response to acknowledge the registration\n        response = FrostMessage(\n            # ... create response message ...\n        )\n        self._set_channel_out_port([response], channel_out)\n=}\n</code></pre> <p>Message Routing</p> <p>This method contains the core routing logic. It looks up the message's target in the <code>routing_map</code> and sends the message to the corresponding output port.</p> <pre><code>method _set_channel_out_port(value, channel_out) {=\n    for message in value:\n        if message.target not in self.routing_map:\n            self.logger.warning(f\"Cannot route message {message} to unknown target {message.target}.\")\n            continue\n\n        index = self.routing_map[message.target]\n        self._set_output_port(message, channel_out[index])\n=}\n</code></pre>"},{"location":"doc_sources/Frost_DataModel/","title":"<code>FrostDataModel</code> Reactor","text":"<p>The <code>FrostDataModel</code> reactor is a key component in the Frost framework that integrates a data model into a reactor. It extends <code>FrostInterface</code>, inheriting its communication capabilities, and adds functionality for managing and interacting with a data model defined in an external file. This allows reactors to maintain state, expose methods, and react to changes in a structured and organized way.</p>"},{"location":"doc_sources/Frost_DataModel/#core-functionalities","title":"Core Functionalities","text":"<ul> <li>Data Model Loading: At startup, it loads a data model from a specified YAML file. This data model defines the reactor's state variables, methods, and their initial values.</li> <li>Request Handling: It processes incoming request messages, such as method invocations or variable read/write requests, and uses a <code>FrostProtocolMng</code> to handle the logic.</li> <li>Response Handling: It processes response messages, which are typically the result of a previous request it sent.</li> <li>Data Model Updates: It includes a timer to periodically check for updates in the data model and send notifications to any subscribers.</li> </ul>"},{"location":"doc_sources/Frost_DataModel/#code-snippets","title":"Code Snippets","text":"<p>Initializing the Data Model</p> <p>This reaction loads the data model from the specified path and initializes the protocol manager.</p> <pre><code>reaction (startup) {=\n    if not os.path.exists(self.data_model_path) and not os.path.isfile(self.data_model_path):\n        self.logger.error(f\"Data model file not found: {self.data_model_path}\")\n        lf.request_stop()\n\n    self.data_model = DataModelBuilder().get_data_model(self.data_model_path)\n    self.protocol_mng = FrostProtocolMng(self.data_model)\n=}\n</code></pre> <p>Processing Requests</p> <p>This reaction handles incoming request messages from the <code>MessageFilter</code>. It distinguishes between different types of requests (e.g., method invocations) and uses the protocol manager to generate a response.</p> <pre><code>reaction (message_filter.requests) -&gt; channel_out {=\n    for bank_index, message in message_filter.requests.value:\n        if message.header.namespace == MsgNamespace.PROTOCOL or message.target != self.name:\n            continue\n\n        // ... logic to handle different request types ...\n\n        response = self.protocol_mng.handle_request(message)\n        self._set_channel_out_port(response, channel_out)\n=}\n</code></pre> <p>Handling Data Model Updates</p> <p>To ensure that subscribers are notified of any changes, the <code>FrostDataModel</code> reactor includes a timer, <code>check_update</code>, that periodically triggers a reaction to send out update messages. This reaction checks if the protocol manager has any pending update messages, and if so, sends them to the appropriate subscribers via the <code>channel_out</code> port.</p> <pre><code>reaction (check_update) -&gt; channel_out{=\n    '''Check if there are any updates in the data model and send them to the subscribers.'''\n\n    update_messages = list(self.protocol_mng.get_update_messages())\n    if not update_messages:\n        return\n\n    self._set_channel_out_port(update_messages, channel_out)\n    self.protocol_mng.clear_update_messages()\n=}\n</code></pre>"},{"location":"doc_sources/Frost_Interface/","title":"<code>FrostInterface</code> Reactor","text":"<p>The <code>FrostInterface</code> reactor establishes the fundamental communication protocol for all Frost components. It extends <code>FrostBase</code> and introduces a standardized way for reactors to connect to the <code>FrostBus</code> and handle incoming and outgoing messages. This reactor is crucial for ensuring that all components in the system can communicate reliably and consistently.</p>"},{"location":"doc_sources/Frost_Interface/#core-functionalities","title":"Core Functionalities","text":"<ul> <li>Bus Connection Management: Implements the logic for a reactor to register itself with the <code>FrostBus</code>. It includes a handshake mechanism that repeatedly attempts to connect until it succeeds or times out.</li> <li>Message Filtering: Incorporates a <code>MessageFilter</code> reactor to process incoming messages. This allows for routing messages based on their type (e.g., requests, responses, errors) and other custom criteria.</li> <li>Standardized Communication Ports: Defines <code>channel_in</code> and <code>channel_out</code> ports for receiving and sending messages, providing a consistent interface for all reactors.</li> </ul>"},{"location":"doc_sources/Frost_Interface/#code-snippets","title":"Code Snippets","text":"<p>Connecting to the Bus</p> <p>This reaction handles the process of registering the reactor with the <code>FrostBus</code>. It sends a registration request and schedules a retry if the connection is not immediately established.</p> <pre><code>reaction(connect_to_bus) -&gt; channel_out, connect_to_bus {=\n    if self.connected:\n        return\n\n    if lf.time.logical_elapsed() &gt; SEC(9):\n        raise Exception(f\"Handshake failed: {self.name} unable to connect to the bus\")\n\n    self._set_channel_out_port(self._create_registration_message(), channel_out)\n    connect_to_bus.schedule(SEC(3))\n=}\n</code></pre> <p>Processing Incoming Messages</p> <p>This reaction forwards all incoming messages from the <code>channel_in</code> port to the <code>MessageFilter</code> for further processing.</p> <pre><code>reaction (channel_in) -&gt; message_filter.messages {=\n    values = self._get_input_values(channel_in)\n    messages = [(bank_index, m) for bank_index, bank_msgs in values for m in bank_msgs]\n    self._set_output_port(messages, message_filter.messages)\n=}\n</code></pre>"},{"location":"doc_sources/Frost_Machine/","title":"<code>FrostMachine</code> Reactor","text":"<p>The <code>FrostMachine</code> reactor is a composite component that combines the functionalities of <code>FrostDataModel</code> and <code>FrostReactor</code>. It is designed to serve as a base for creating \"machine\" actors in the Frost ecosystem\u2014components that have both a data model and the ability to communicate over the <code>FrostBus</code>.</p>"},{"location":"doc_sources/Frost_Machine/#core-functionalities","title":"Core Functionalities","text":"<ul> <li>Inheritance: It inherits from both <code>FrostDataModel</code> and <code>FrostReactor</code>, giving it the combined capabilities of both. This means it can manage a data model, connect to the <code>FrostBus</code>, and handle messages according to the Frost protocol.</li> <li>Update Step: It introduces an <code>update_step</code> parameter, which can be used to define a time step for periodic updates within the machine. This is useful for simulations or for components that need to perform actions at regular intervals.</li> </ul>"},{"location":"doc_sources/Frost_Machine/#code-snippet","title":"Code Snippet","text":"<p>The definition of the <code>FrostMachine</code> reactor is straightforward, as it primarily relies on inheritance to acquire its functionality.</p> <pre><code>reactor FrostMachine(_update_step = 1000 msec) extends FrostDataModel, FrostReactor {\n    '''Reactor implementing the common logic for Frost machines.\n\n    Args:\n        _update_step (int): The time step for periodic updates in the machine.\n    '''\n\n    state update_step = _update_step\n}\n</code></pre>"},{"location":"doc_sources/Frost_Reactor/","title":"<code>FrostReactor</code> Reactor","text":"<p>The <code>FrostReactor</code> is a base component for Frost actors that need to communicate over the <code>FrostBus</code>. It extends the <code>FrostInterface</code> and provides the essential logic for a reactor to initialize itself and establish a connection with the bus at startup.</p>"},{"location":"doc_sources/Frost_Reactor/#core-functionalities","title":"Core Functionalities","text":"<ul> <li>Automatic Bus Connection: The primary feature of <code>FrostReactor</code> is its automatic connection to the <code>FrostBus</code>. At startup, it triggers a logical action <code>connect_to_bus</code>, which is handled by the parent <code>FrostInterface</code> to begin the registration process.</li> <li>Initialization Logging: It logs an informational message upon initialization, which is helpful for debugging and tracking the lifecycle of reactors.</li> </ul>"},{"location":"doc_sources/Frost_Reactor/#code-snippet","title":"Code Snippet","text":"<p>This reaction is triggered at startup and is responsible for initiating the connection to the <code>FrostBus</code>.</p> <pre><code>reaction (startup) -&gt; connect_to_bus {=\n    '''Initialize the reactor and trigger connection to the FrostBus.'''\n    self.logger.info(f\"Initializing FrostReactor: {self._get_reactor_name()}\")\n\n    # Trigger the connection to the bus.\n    connect_to_bus.schedule(0)\n=}\n</code></pre>"},{"location":"doc_sources/Introduction/","title":"Introduction to Frost Components","text":"<p>The Frost framework is built upon a set of modular and reusable reactors, each designed to provide specific functionalities for building robust, event-driven systems. These components are organized in an inheritance hierarchy, allowing them to share common functionalities while also providing specialized capabilities. Understanding this hierarchy is key to effectively using and extending the Frost framework.</p> <p>At the root of the hierarchy is <code>FrostBase</code>, which provides common utilities like logging and parameter management. From there, the components branch into more specialized roles.</p>"},{"location":"doc_sources/Introduction/#component-inheritance-tree","title":"Component Inheritance Tree","text":"<p>The following diagram illustrates the inheritance relationships between the core Frost components:</p> <pre><code>graph TD\n    A[FrostBase] --&gt; B(FrostInterface)\n    A --&gt; C(MessageFilter)\n    B --&gt; D(FrostDataModel)\n    B --&gt; E(FrostReactor)\n    D --&gt; F(FrostBus)\n    D --&gt; G(FrostMachine)\n    E --&gt; G(FrostMachine)</code></pre>"},{"location":"doc_sources/Introduction/#core-components-explained","title":"Core Components Explained","text":"<ul> <li> <p><code>FrostBase</code>: The foundational reactor from which all other Frost components inherit. It provides essential utilities for logging, configuration, and message passing.</p> </li> <li> <p><code>FrostInterface</code>: Extends <code>FrostBase</code> to establish the fundamental communication protocol for Frost components. It manages the connection to the <code>FrostBus</code> and incorporates a <code>MessageFilter</code> to handle incoming messages.</p> </li> <li> <p><code>MessageFilter</code>: A specialized reactor that processes and routes incoming messages based on their type (e.g., <code>REQUEST</code>, <code>RESPONSE</code>). It allows reactors to subscribe to specific message types, decoupling message receiving from processing.</p> </li> <li> <p><code>FrostDataModel</code>: Inherits from <code>FrostInterface</code> and integrates a data model into a reactor. It is responsible for loading the data model from a file, handling data-related requests (e.g., method invocations, variable updates), and notifying subscribers of changes.</p> </li> <li> <p><code>FrostReactor</code>: A base component for Frost actors that need to communicate over the <code>FrostBus</code>. It extends <code>FrostInterface</code> and provides the logic for a reactor to automatically connect to the bus at startup.</p> </li> <li> <p><code>FrostMachine</code>: A paramount reactor that inherits from both <code>FrostDataModel</code> and <code>FrostReactor</code>. It enables the describtion of machines behavior and to link it to the exposed data model nodes.</p> </li> <li> <p><code>FrostBus</code>: A central message-routing component that manages the registration of all Frost components and ensures that messages are delivered to their intended targets. It acts as message broker among machineries and components involved in the simulation.</p> </li> </ul>"},{"location":"doc_sources/Message_Filter/","title":"<code>MessageFilter</code> Reactor","text":"<p>The <code>MessageFilter</code> is a specialized reactor designed to process and route incoming Frost messages. It acts as a gatekeeper, examining each message and directing it to the appropriate output port based on its type and content. This allows for a clean separation of concerns, as reactors can subscribe to specific types of messages (requests, responses, or errors) without needing to parse every incoming message themselves.</p>"},{"location":"doc_sources/Message_Filter/#core-functionalities","title":"Core Functionalities","text":"<ul> <li>Message-Type Filtering: It categorizes messages based on their header type (<code>REQUEST</code>, <code>RESPONSE</code>, <code>ERROR</code>) and forwards them to corresponding output ports (<code>requests</code>, <code>responses</code>, <code>errors</code>).</li> <li>Custom Filtering Logic: Supports custom filter callbacks that allow for more advanced filtering based on message content, sender, or other criteria. Messages that do not meet the filter criteria are sent to a <code>discarded_messages</code> port.</li> <li>Decoupling: By handling the initial message triage, it decouples the message-receiving logic from the message-processing logic within other reactors.</li> </ul>"},{"location":"doc_sources/Message_Filter/#code-snippets","title":"Code Snippets","text":"<p>Handling Messages</p> <p>This reaction is the core of the <code>MessageFilter</code>. It iterates through incoming messages, applies the filter callbacks, and routes each message to the appropriate output port.</p> <pre><code>reaction (messages) -&gt; requests, responses, errors, discarded_messages {=\n    for message in messages.value:\n        if not isinstance(message[1], self._message_type):\n            self.logger.warning(f\"Invalid message type: {type(message[1])}\")\n            continue\n\n        if self._should_process_message(message):\n            self._handle_message(message, requests, responses, errors)\n        else:\n            self._set_output_port(message, discarded_messages)\n=}\n</code></pre> <p>Custom Filter Application</p> <p>This method checks if a message should be processed by applying a series of user-defined filter callbacks.</p> <pre><code>method _should_process_message(message) {=\n    for callback in self._filter_callbacks:\n        if not callback(message):\n            return False\n    return True\n=}\n</code></pre>"},{"location":"doc_sources/Publisher_Subscriber/","title":"Publisher-Subscriber Example","text":"<p>This example provides a classic publisher-subscriber pattern example. In this model, a <code>Publisher</code> reactor is responsible for generating data, while a <code>Subscriber</code> reactor listens for these updates and react accordingly. </p>"},{"location":"doc_sources/Publisher_Subscriber/#the-data-models","title":"The Data Models","text":"<p>The simulation is built upon two distinct data models, one for the publisher and one for the subscriber. These models define the structure of the data that each component manages.</p> <p>Publisher Data Model (<code>publisher.yml</code>)</p> <p>The publisher's data model is straightforward, containing a single <code>word</code> node. The <code>Publisher</code> reactor will periodically update the value of this node with a new word from a predefined list.</p> <pre><code>name: \"publisher\"\ndescription: \"Publisher\"\nroot:\n  !!FolderNode\n  name: \"root\"\n  children:\n    - !!StringVariableNode\n      name: \"word\"\n      initial_value: \"\"\n</code></pre> <p>Subscriber Data Model (<code>subscriber.yml</code>)</p> <p>The subscriber's data model contains a <code>sentence</code> node. The <code>Subscriber</code> reactor's goal is to build a sentence by concatenating the words it receives from the publisher.</p> <pre><code>name: \"subscriber\"\ndescription: \"Subscriber\"\nroot:\n  !!FolderNode\n  name: \"root\"\n  children:\n    - !!StringVariableNode\n      name: \"sentence\"\n      initial_value: \"\"\n</code></pre>"},{"location":"doc_sources/Publisher_Subscriber/#the-publisher-reactor","title":"The <code>Publisher</code> Reactor","text":"<p>The <code>Publisher</code> reactor is the source of information in this system. It is designed to periodically generate a new piece of data and publish it. The underlying Frost framework ensures that any component that has subscribed to this data is automatically notified of the update.</p> <pre><code>reactor Publisher extends FrostDataModel {\n    state words = [\"Hello\", \"world\", \"this\", \"is\", \"a\", \"test\", \"message\"]\n    state word_node\n\n    reaction(startup) {=\n        self.word_node = self.data_model.get_node(\"root/word\")\n    =}\n\n    timer publish_timer(1 sec, 2 sec)\n\n    reaction(publish_timer) {=\n        if not self.words:\n            lf.request_stop()\n            return\n\n        word = self.words.pop(0)\n        self.word_node.value = word\n    =}\n}\n</code></pre>"},{"location":"doc_sources/Publisher_Subscriber/#the-subscriber-reactor","title":"The <code>Subscriber</code> Reactor","text":"<p>The <code>Subscriber</code> reactor's function is to listen for and consume the data published by the <code>Publisher</code>. To do this, it must first express its interest by sending a subscription request. At startup, it sends a message to the <code>Publisher</code> to subscribe to the <code>root/word</code> node. From that point on, whenever the <code>Publisher</code> updates the <code>word</code> node, the <code>Subscriber</code> will receive a notification and append the new word to its <code>sentence</code> node.</p> <pre><code>reactor Subscriber extends FrostDataModel {  \n    state sentence\n\n    reaction(startup) -&gt; channel_out {=\n        self.sentence = self.data_model.get_node(\"root/sentence\")\n        // Send a subscription request to the publisher for \"root/word\"\n        message = FrostMessage(\n            sender=self.name,\n            target=\"publisher\",\n            identifier=str(uuid.uuid4()),\n            header=FrostHeader(\n                type=MsgType.REQUEST,\n                version=(1, 0, 0),\n                namespace=MsgNamespace.VARIABLE,\n                msg_name=VariableMsgName.SUBSCRIBE,\n            ),\n            payload=VariablePayload(node=\"root/word\"),\n        )\n        self._set_output_port(message, channel_out)\n    =}\n\n    reaction(message_filter.responses) {=\n        message = message_filter.responses.value[0][1]\n        if message.header.namespace == MsgNamespace.VARIABLE and message.header.msg_name == VariableMsgName.UPDATE:\n            self.sentence.value += \" \" + message.payload.value\n    =}\n}\n</code></pre>"},{"location":"doc_sources/Publisher_Subscriber/#the-main-reactor","title":"The <code>main</code> Reactor","text":"<p>The <code>main</code> reactor instantiates and connects the <code>Publisher</code> and <code>Subscriber</code> reactors. It establishes the communication channels that allow the exchange of messages between the two components.</p> <pre><code>main reactor {\n    publisher = new Publisher(name = \"publisher\")\n    subscriber = new Subscriber(name = \"subscriber\")\n\n    publisher.channel_out -&gt; subscriber.channel_in after 100 msec\n    subscriber.channel_out -&gt; publisher.channel_in after 100 msec\n}\n</code></pre>"},{"location":"doc_sources/Sensor_Alarm/","title":"Sensor-Alarm Example","text":"<p>This example demonstrates a fundamental event-driven interaction between a <code>Sensor</code> and an <code>Alarm</code>. The <code>Sensor</code> reactor is designed to periodically monitor for a specific condition. If the condition is met, it triggers an event by sending a message to the <code>Alarm</code> reactor, which then takes appropriate action. </p>"},{"location":"doc_sources/Sensor_Alarm/#the-data-models","title":"The Data Models","text":"<p>The simulation is defined by two simple data models, one for the sensor and one for the alarm, which specify their respective states.</p> <p>Sensor Data Model (<code>sensor.yml</code>)</p> <p>The sensor's data model contains a single boolean node called <code>detected</code>. This node represents whether the sensor has detected the event it is monitoring. It is initialized to <code>False</code>.</p> <pre><code>name: \"sensor\"\ndescription: \"Sensor\"\nroot:\n  !!FolderNode\n  name: \"root\"\n  children:\n    - !!BooleanVariableNode\n      name: \"detected\"\n      initial_value: False\n</code></pre> <p>Alarm Data Model (<code>alarm.yml</code>)</p> <p>The alarm's data model includes a boolean node called <code>ringing</code>, which is also initialized to <code>False</code>. This node represents the state of the alarm. The <code>Alarm</code> reactor will set this to <code>True</code> when it receives a signal from the sensor.</p> <pre><code>name: \"alarm\"\ndescription: \"Alarm\"\nroot:\n  !!FolderNode\n  name: \"root\"\n  children:\n    - !!BooleanVariableNode\n      name: \"ringing\"\n      initial_value: False\n</code></pre>"},{"location":"doc_sources/Sensor_Alarm/#the-sensor-reactor","title":"The <code>Sensor</code> Reactor","text":"<p>The <code>Sensor</code> reactor simulates the behavior of a real-world sensor. It uses a timer to periodically perform a check. In this simulation, the check involves generating a random number. If this number exceeds a predefined threshold, the sensor considers the event \"detected,\" sets its <code>detected</code> state to <code>True</code>, and sends a message to the <code>Alarm</code> reactor to activate it.</p> <pre><code>reactor Sensor extends FrostMachine {\n    state detected\n\n    reaction(startup) {=\n        self.detected = self.data_model.get_node(\"root/detected\")\n    =}\n\n    timer check_timer(1000 msec, 3000 msec)\n\n    reaction(check_timer) -&gt; channel_out {=\n        // Simulate random detection\n        new_value = random.random()\n        self.detected.value = new_value &gt; 0.9\n\n        if self.detected.value:\n            message = FrostMessage(\n                sender=self.name,\n                target=\"alarm\",\n                // ... message header ...\n                payload=VariablePayload(\n                    node=\"root/ringing\",\n                    value=self.detected.value,\n                ),\n            )\n            self._set_channel_out_port(message, channel_out)\n    =}\n}\n</code></pre>"},{"location":"doc_sources/Sensor_Alarm/#the-alarm-reactor","title":"The <code>Alarm</code> Reactor","text":"<p>The <code>Alarm</code> reactor represents the alarm device itself. It has a <code>ringing</code> state that is initially <code>False</code>. The <code>Alarm</code> reactor also has a timer that periodically checks the value of its <code>ringing</code> state. If it finds that <code>ringing</code> is <code>True</code>, it logs a \"RINGING!\" message to the console and requests the simulation to stop. This demonstrates how a component can react to an event triggered by another component and take a decisive action.</p> <pre><code>reactor Alarm extends FrostMachine {\n    state ringing\n\n    reaction(startup) {=\n        self.ringing = self.data_model.get_node(\"root/ringing\")\n    =}\n\n    timer check_status(1 sec, 1 sec)\n\n    reaction(check_status) {=\n        if self.ringing.value:\n            self.logger.error(\"Alarm is RINGING!\")\n            lf.request_stop()\n    =}\n}\n</code></pre> <pre><code>main reactor {\n    frost_bus = new FrostBus(name = \"frost_bus\", width = 2)\n    sensor = new Sensor(name = \"sensor\")\n    alarm = new Alarm(name = \"alarm\")\n\n    frost_bus.channel_out -&gt; sensor.channel_in, alarm.channel_in after 10 msec\n    sensor.channel_out, alarm.channel_out -&gt; frost_bus.channel_in after 10 msec\n}\n</code></pre>"},{"location":"doc_sources/Stock_Market/","title":"Stock Market Simulation","text":"<p>This example demonstrates a simple stock market simulation with Frost components. The simulation features two main components: a <code>Stock_Market</code> reactor that simulates fluctuating stock prices and an <code>Investor</code> reactor that makes trading decisions based on market trends.</p>"},{"location":"doc_sources/Stock_Market/#the-stockmarket-data-model","title":"The <code>StockMarket</code> Data Model","text":"<p>The simulation starts with a data model that defines the initial state of the stocks. This model is defined in a YAML file and loaded by the <code>Stock_Market</code> reactor at startup. It establishes the initial values for three stocks: <code>action_1</code>, <code>action_2</code>, and <code>action_3</code>.</p> <pre><code>name: \"stock_market\"\nmachine_category: \"unknown\"\nmachine_type: \"unknown\"\nmachine_model: \"unknown\"\ndescription: \"Stock Market\"\nroot:\n  !!FolderNode\n  name: \"root\"\n  description: \"none\"\n  children:\n    - !!NumericalVariableNode\n      name: \"action_1\"\n      initial_value: 27.5\n    - !!NumericalVariableNode\n      name: \"action_2\"\n      initial_value: 50.0\n    - !!NumericalVariableNode\n      name: \"action_3\"\n      initial_value: 12.5\n</code></pre>"},{"location":"doc_sources/Stock_Market/#the-stock_market-reactor","title":"The <code>Stock_Market</code> Reactor","text":"<p>The <code>Stock_Market</code> reactor is responsible for emulating the dynamic behavior of the stock market with a random change of the action values. At startup, it loads the initial stock values from the data model. It then uses a timer to periodically update the values of the stocks, introducing random fluctuations to simulate market volatility. This reactor essentially serves as the \"environment\" for our simulation.</p> <pre><code>reactor Stock_Market extends FrostDataModel {\n    state action_1\n    state action_2\n    state action_3\n\n    timer update_timer(1 sec, 100 msec)\n    reaction(update_timer) {=\n        // Randomly update stock values, ensuring they don't go below zero\n        if self.action_1.value + random.choice([-1, 1]) &gt; 0:\n            self.action_1.value += random.choice([-1, 1])\n        if self.action_2.value + random.choice([-2, 2]) &gt; 0:\n            self.action_2.value += random.choice([-2, 2])\n        if self.action_3.value + random.choice([-3, 3]) &gt; 0:\n            self.action_3.value += random.choice([-3, 3])\n    =}\n}\n</code></pre>"},{"location":"doc_sources/Stock_Market/#the-investor-reactor","title":"The <code>Investor</code> Reactor","text":"<p>The <code>Investor</code> reactor acts as an autonomous agent that implements a simple trading strategy. It periodically sends requests to the <code>Stock_Market</code> reactor to get the current stock prices. Based on the received values, it decides whether to buy or sell stocks.</p> <ul> <li>Buying Strategy: If a stock's price falls below a predefined <code>threshold</code>, the investor sees a buying opportunity and purchases a number of shares. The quantity is determined by how far the price is below the threshold.</li> <li>Selling Strategy: If a stock's price rises above the <code>threshold</code>, the investor sells its holdings of that stock to realize a profit.</li> </ul> <p>This reactor demonstrates how to model agent-like behavior and decision-making logic in Lingua Franca.</p> <pre><code>reactor Investor extends FrostBase {\n    input channel_in\n    output channel_out\n    state threshold = 20.0\n    state money = 1000.0\n\n    reaction(channel_in) {=\n        // ... receive message and extract stock value ...\n        percentage = float(value / self.threshold) * 100.0\n        if percentage &gt; 100.0 and self.action_1 &gt; 0:\n            // Sell stock\n            self.money += value * self.action_1\n            self.action_1 = 0\n        elif percentage &lt; 100.0:\n            // Buy stock if there is enough money\n            num_to_buy = int(100 - percentage)\n            cost = num_to_buy * value\n            if cost &lt; self.money:\n                self.action_1 += num_to_buy\n                self.money -= cost\n    =}\n}\n</code></pre>"},{"location":"doc_sources/Stock_Market/#the-main-reactor","title":"The <code>main</code> Reactor","text":"<p>The <code>main</code> reactor is the top-level component that assembles the simulation. It instantiates both the <code>Stock_Market</code> and <code>Investor</code> reactors and establishes the communication channels between them. This connection creates a closed loop: the <code>Investor</code> requests data from the <code>Stock_Market</code>, which in turn provides the data that drives the <code>Investor</code>'s decisions.</p> <pre><code>main reactor {\n    stock_market_action = new Stock_Market(name = \"stock_market\")\n    investor = new Investor(name = \"investor\")\n\n    stock_market_action.channel_out -&gt; investor.channel_in after 0\n    investor.channel_out -&gt; stock_market_action.channel_in after 0\n}\n</code></pre>"},{"location":"doc_sources/Target_Initiator/","title":"Target-Initiator Example","text":"<p>This example provides a request-response interaction. In this scenario, an <code>Initiator</code> reactor sends a request to a <code>Target</code> reactor by invoking one of its methods. The <code>Target</code> then processes the request and sends a response back to the <code>Initiator</code>. This pattern is often referred to as a Remote Procedure Call (RPC), and it is essential for building systems where components need to query each other for information or trigger actions.</p>"},{"location":"doc_sources/Target_Initiator/#the-target-data-model","title":"The <code>Target</code> Data Model","text":"<p>The <code>Target</code> reactor's data model serves as its public API, defining the methods that other reactors can invoke. In this case, it exposes a single asynchronous method called <code>answer</code>, which accepts a string <code>message</code> as an argument and is expected to return a string.</p> <pre><code>name: \"target\"\ndescription: \"Target\"\nroot:\n  !!FolderNode\n  name: \"Methods\"\n  children:\n    - !!AsyncMethodNode\n      name: \"answer\"\n      description: \"Answer to the message\"\n      parameters:\n        - !!StringVariableNode\n          name: \"message\"\n          description: \"message to answer\"\n          default_value: \"\"\n      returns:\n        - !!StringVariableNode\n          name: \"return\"\n          description: \"the answer\"\n</code></pre>"},{"location":"doc_sources/Target_Initiator/#the-initiator-reactor","title":"The <code>Initiator</code> Reactor","text":"<p>The <code>Initiator</code> reactor is the client in this interaction. Its role is to initiate the communication by sending a request to the <code>Target</code>. At startup, it builds a message to invoke the <code>answer</code> method on the <code>Target</code>, passing a question as the argument. After sending the request, it waits for a response. When the response arrives, it logs the answer provided by the <code>Target</code>.</p> <pre><code>reactor Initiator extends FrostBase {\n    input channel_in\n    output channel_out\n\n    reaction(startup) -&gt; channel_out {=\n        // Send a message to invoke the \"answer\" method on the target\n        message = FrostMessage(\n            sender=self.name,\n            target=\"target\",\n            // ... message header for method invocation ...\n            payload=MethodPayload(\n                node=\"Methods/answer\",\n                args=[\"What is your name?\"],\n                kwargs={},\n            ),\n        )\n        self._set_channel_out_port(message, channel_out)\n    =}\n\n    reaction(channel_in) {=\n        // Receive the response from the target\n        message = channel_in.value[0]\n        if message.header.type == MsgType.RESPONSE and message.header.namespace == MsgNamespace.METHOD:\n            self.logger.info(f\"{message.sender}: {message.payload.ret['response']}\")\n    =}\n}\n</code></pre>"},{"location":"doc_sources/Target_Initiator/#the-target-reactor","title":"The <code>Target</code> Reactor","text":"<p>The <code>Target</code> reactor is the server in this scenario. It is responsible for implementing the logic of the <code>answer</code> method. At startup, it retrieves the <code>answer</code> method node from its data model and assigns a callback function to it. When the <code>Initiator</code> (or any other reactor) invokes this method, the assigned callback is executed. In this simple example, the callback ignores the input message and returns a fixed string, \"Bob\".</p> <pre><code>reactor Target extends FrostMachine {\n    state method_node\n    state target_name = \"Bob\"\n\n    reaction(startup) {=\n        method_node = self.data_model.get_node(\"Methods/answer\")\n        method_node.callback = self.answer\n    =}\n\n    method answer(message) {=\n        // This method is called when the initiator invokes \"Methods/answer\"\n        return self.target_name\n    =}\n}\n</code></pre>"},{"location":"doc_sources/Target_Initiator/#the-main-reactor","title":"The <code>main</code> Reactor","text":"<p>The <code>main</code> reactor is responsible for assembling the entire simulation. It instantiates the <code>Initiator</code>, <code>Target</code>, and a <code>FrostBus</code>. The <code>FrostBus</code> acts as a message broker, facilitating communication between the other reactors. The <code>main</code> reactor connects the <code>Initiator</code> and <code>Target</code> to the bus, which allows the <code>Initiator</code>'s method invocation to be routed to the <code>Target</code>, and the <code>Target</code>'s response to be sent back.</p> <pre><code>main reactor {\n    frost_bus = new FrostBus(name = \"frost_bus\", width = 2)\n    initiator = new Initiator(name = \"initiator\")\n    target = new Target(name = \"target\")\n\n    frost_bus.channel_out -&gt; initiator.channel_in, target.channel_in after 10 msec\n    initiator.channel_out, target.channel_out -&gt; frost_bus.channel_in after 10 msec\n}\n</code></pre>"}]}